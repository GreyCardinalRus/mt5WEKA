//+------------------------------------------------------------------+
//|                                                neuro-example.mq5 |
//|                        Copyright 2012, MetaQuotes Software Corp. |
//|                                              http://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2012, MetaQuotes Software Corp."
#property link      "http://www.mql5.com"
#property version   "1.00"
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
#include <Trade\Trade.mqh>        //подключаем библиотеку для совершения торговых операций
#include <Trade\PositionInfo.mqh> //подключаем библиотеку для получения информации о позициях

//--- значения весовых коэффициентов
input double w0=0.1;
input double w1=0.1;
input double w2=0.1;
input double w3=0.1;
input double w4=0.1;
input double w5=0.1;
input double w6=0.1;
input double w7=0.1;
input double w8=0.1;
input double w9=0.1;

int               iRSI_handle;  // переменная для хранения хендла индикатора
double            iRSI_buf[];   // динамический массив для хранения значений индикатора

double            inputs[10];   // массив для хранения входных сигналов
double            weight[10];   // массив для хранения весовых коэффициентов

double            out;          // переменная для хранения выходного значения нейрона

string            my_symbol;    // переменная для хранения символа
ENUM_TIMEFRAMES   my_timeframe; // переменная для хранения таймфрейма
double            lot_size;     // переменная для хранения минимального объема совершаемой сделки

CTrade            m_Trade;      // объект для выполнения торговых операций
CPositionInfo     m_Position;   // объект для получения информации о позициях
//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
int OnInit()
  {
//--- сохраним текущий символ графика для дальнейшей работы советника именно на этом символе
   my_symbol=Symbol();
//--- сохраним текущий период графика для дальнейшей работы советника именно на этом периоде
   my_timeframe=PERIOD_CURRENT;
//--- сохраним минимальный объем совершаемой сделки
   lot_size=SymbolInfoDouble(my_symbol,SYMBOL_VOLUME_MIN);
//--- подключаем индикатор и получаем его хендл
   iRSI_handle=iRSI(my_symbol,my_timeframe,14,PRICE_CLOSE);
//--- проверяем наличие хендла индикатора
   if(iRSI_handle==INVALID_HANDLE)
     {
      //--- хендл не получен, выводим сообщение в лог об ошибке, завершаем работу с ошибкой
      Print("Не удалось получить хендл индикатора");
      return(-1);
     }
//--- добавляем индикатор на ценовой график
   ChartIndicatorAdd(ChartID(),0,iRSI_handle);
//--- устанавливаем индексацию для массива iRSI_buf как в таймсерии
   ArraySetAsSeries(iRSI_buf,true);
//--- переносим весовые коэффициенты в массив
   weight[0]=w0;
   weight[1]=w1;
   weight[2]=w2;
   weight[3]=w3;
   weight[4]=w4;
   weight[5]=w5;
   weight[6]=w6;
   weight[7]=w7;
   weight[8]=w8;
   weight[9]=w9;
//--- возвращаем 0, инициализация завершена
   return(0);
  }
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//--- удаляем хэндл индикатора и освобождаем занимаемую им память
   IndicatorRelease(iRSI_handle);
//--- освобождаем динамический массив iRSI_buf от данных
   ArrayFree(iRSI_buf);
  }
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
//--- переменная для хранения результатов работы с буфером индикатора
   int err1=0;
//--- копируем данные из индикаторного массива в динамический массив iRSI_buf для дальнейшей работы с ними
   err1=CopyBuffer(iRSI_handle,0,1,10,iRSI_buf);
//--- если есть ошибки, то выводим сообщение в лог об ошибке и выходим из функции
   if(err1<0)
     {
      Print("Не удалось скопировать данные из индикаторного буфера");
      return;
     }
//---
   double d1=0.0;                                 //нижняя граница интервала для нормализации значений
   double d2=1.0;                                 //верхняя граница интервала для нормализации значений
   double x_min=iRSI_buf[ArrayMinimum(iRSI_buf)]; //минимальное значение на интервале
   double x_max=iRSI_buf[ArrayMaximum(iRSI_buf)]; //максимальное значение на интервале

//--- В цикле заполняем массив входов значениями индикатора с предварительной нормализацией
   for(int i=0;i<ArraySize(inputs);i++)
     {
      inputs[i]=(((iRSI_buf[i]-x_min)*(d2-d1))/(x_max-x_min))+d1;
     }
//--- записываем результат вычисления нейрона в переменную out
   out=CalculateNeuron(inputs,weight);
//--- если значение выхода нейрона меньше 0.5
   if(out<0.5)
     {
      //--- если уже существует позиция по этому символу
      if(m_Position.Select(my_symbol))
        {
         //--- и тип этой позиции Sell, то закрываем ее
         if(m_Position.PositionType()==POSITION_TYPE_SELL) m_Trade.PositionClose(my_symbol);
         //--- а если тип этой позиции Buy, то выходим
         if(m_Position.PositionType()==POSITION_TYPE_BUY) return;
        }
      //--- если дошли сюда, значит позиции нет, открываем ее
      m_Trade.Buy(lot_size,my_symbol);
     }
//--- если значение выхода нейрона больше или равно 0.5
   if(out>=0.5)
     {
      //--- если уже существует позиция по этому символу
      if(m_Position.Select(my_symbol))
        {
         //--- и тип этой позиции Buy, то закрываем ее
         if(m_Position.PositionType()==POSITION_TYPE_BUY) m_Trade.PositionClose(my_symbol);
         //--- а если тип этой позиции Sell, то выходим
         if(m_Position.PositionType()==POSITION_TYPE_SELL) return;
        }
      //--- если дошли сюда, значит позиции нет, открываем ее
      m_Trade.Sell(lot_size,my_symbol);
     }
  }
//+------------------------------------------------------------------+
//|   Функция вычисления нейрона                                     |
//+------------------------------------------------------------------+
double CalculateNeuron(double &x[],double &w[])
  {
//--- переменная для хранения средневзвешенной суммы входных сигналов
   double NET=0.0;
//--- В цикле по количеству входов получаем средневзвешенную сумму входов
   for(int n=0;n<ArraySize(x);n++)
     {
      NET+=x[n]*w[n];
     }
//--- умножаем средневзвешенную сумму входов на добавочный коэффициент
   NET*=0.4;
//--- передаем средневзвешенную сумму входов в функцию активации и возвращаем ее значение
   return(ActivateNeuron(NET));
  }
//+------------------------------------------------------------------+
//|   Функция активации нейрона                                      |
//+------------------------------------------------------------------+
double ActivateNeuron(double x)
  {
//--- переменная для хранения результата функции активации
   double Out;
//--- сигмоид
   Out=1/(1+exp(-x));
//--- возвращаем значение функции активации
   return(Out);
  }
//+------------------------------------------------------------------+
